{
  "version": 3,
  "sources": ["../../../../../packages/common/node_modules/ini/lib/ini.js"],
  "sourcesContent": ["const { hasOwnProperty } = Object.prototype\n\n/* istanbul ignore next */\nconst eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nconst encode = (obj, opt) => {\n  const children = []\n  let out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || Object.create(null)\n    opt.whitespace = opt.whitespace === true\n  }\n\n  const separator = opt.whitespace ? ' = ' : '='\n\n  for (const k of Object.keys(obj)) {\n    const val = obj[k]\n    if (val && Array.isArray(val)) {\n      for (const item of val) {\n        out += safe(k + '[]') + separator + safe(item) + eol\n      }\n    } else if (val && typeof val === 'object') {\n      children.push(k)\n    } else {\n      out += safe(k) + separator + safe(val) + eol\n    }\n  }\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + eol + out\n  }\n\n  for (const k of children) {\n    const nk = dotSplit(k).join('\\\\.')\n    const section = (opt.section ? opt.section + '.' : '') + nk\n    const { whitespace } = opt\n    const child = encode(obj[k], {\n      section,\n      whitespace,\n    })\n    if (out.length && child.length) {\n      out += eol\n    }\n\n    out += child\n  }\n\n  return out\n}\n\nconst dotSplit = str =>\n  str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./)\n    .map(part =>\n      part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001'))\n\nconst decode = str => {\n  const out = Object.create(null)\n  let p = out\n  let section = null\n  //          section     |key      = value\n  const re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  const lines = str.split(/[\\r\\n]+/g)\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/)) {\n      continue\n    }\n    const match = line.match(re)\n    if (!match) {\n      continue\n    }\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null)\n        continue\n      }\n      p = out[section] = out[section] || Object.create(null)\n      continue\n    }\n    const keyRaw = unsafe(match[2])\n    const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]'\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw\n    if (key === '__proto__') {\n      continue\n    }\n    const valueRaw = match[3] ? unsafe(match[4]) : true\n    const value = valueRaw === 'true' ||\n      valueRaw === 'false' ||\n      valueRaw === 'null' ? JSON.parse(valueRaw)\n      : valueRaw\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) {\n        p[key] = []\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]]\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    } else {\n      p[key] = value\n    }\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = []\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) ||\n        typeof out[k] !== 'object' ||\n        Array.isArray(out[k])) {\n      continue\n    }\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = dotSplit(k)\n    p = out\n    const l = parts.pop()\n    const nl = l.replace(/\\\\\\./g, '.')\n    for (const part of parts) {\n      if (part === '__proto__') {\n        continue\n      }\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {\n        p[part] = Object.create(null)\n      }\n      p = p[part]\n    }\n    if (p === out && nl === l) {\n      continue\n    }\n\n    p[nl] = out[k]\n    remove.push(k)\n  }\n  for (const del of remove) {\n    delete out[del]\n  }\n\n  return out\n}\n\nconst isQuoted = val => {\n  return (val.startsWith('\"') && val.endsWith('\"')) ||\n    (val.startsWith(\"'\") && val.endsWith(\"'\"))\n}\n\nconst safe = val => {\n  if (\n    typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 && isQuoted(val)) ||\n    val !== val.trim()\n  ) {\n    return JSON.stringify(val)\n  }\n  return val.split(';').join('\\\\;').split('#').join('\\\\#')\n}\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.slice(1, -1)\n    }\n    try {\n      val = JSON.parse(val)\n    } catch {\n      // ignore errors\n    }\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false\n    let unesc = ''\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c\n        } else {\n          unesc += '\\\\' + c\n        }\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1) {\n        break\n      } else if (c === '\\\\') {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc) {\n      unesc += '\\\\'\n    }\n\n    return unesc.trim()\n  }\n  return val\n}\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe,\n}\n"],
  "mappings": "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",
  "names": []
}
